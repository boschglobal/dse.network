/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version 39.4.5 Thu Apr  4 09:21:31 2024.
 */

#include <string.h>

#include "stub.h"

static inline uint8_t pack_left_shift_u8(
    uint8_t value, uint8_t shift, uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static inline uint8_t pack_left_shift_u16(
    uint16_t value, uint8_t shift, uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static inline uint8_t pack_left_shift_u32(
    uint32_t value, uint8_t shift, uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static inline uint8_t pack_left_shift_u64(
    uint64_t value, uint8_t shift, uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static inline uint8_t pack_right_shift_u8(
    uint8_t value, uint8_t shift, uint8_t mask)
{
    return (uint8_t)((uint8_t)(value >> shift) & mask);
}

static inline uint8_t pack_right_shift_u16(
    uint16_t value, uint8_t shift, uint8_t mask)
{
    return (uint8_t)((uint8_t)(value >> shift) & mask);
}

static inline uint8_t pack_right_shift_u32(
    uint32_t value, uint8_t shift, uint8_t mask)
{
    return (uint8_t)((uint8_t)(value >> shift) & mask);
}

static inline uint8_t pack_right_shift_u64(
    uint64_t value, uint8_t shift, uint8_t mask)
{
    return (uint8_t)((uint8_t)(value >> shift) & mask);
}

static inline uint8_t unpack_left_shift_u8(
    uint8_t value, uint8_t shift, uint8_t mask)
{
    return (uint8_t)((uint8_t)(value & mask) << shift);
}

static inline uint16_t unpack_left_shift_u16(
    uint8_t value, uint8_t shift, uint8_t mask)
{
    return (uint16_t)((uint16_t)(value & mask) << shift);
}

static inline uint32_t unpack_left_shift_u32(
    uint8_t value, uint8_t shift, uint8_t mask)
{
    return (uint32_t)((uint32_t)(value & mask) << shift);
}

static inline uint64_t unpack_left_shift_u64(
    uint8_t value, uint8_t shift, uint8_t mask)
{
    return (uint64_t)((uint64_t)(value & mask) << shift);
}

static inline uint8_t unpack_right_shift_u8(
    uint8_t value, uint8_t shift, uint8_t mask)
{
    return (uint8_t)((uint8_t)(value & mask) >> shift);
}

static inline uint16_t unpack_right_shift_u16(
    uint8_t value, uint8_t shift, uint8_t mask)
{
    return (uint16_t)((uint16_t)(value & mask) >> shift);
}

static inline uint32_t unpack_right_shift_u32(
    uint8_t value, uint8_t shift, uint8_t mask)
{
    return (uint32_t)((uint32_t)(value & mask) >> shift);
}

static inline uint64_t unpack_right_shift_u64(
    uint8_t value, uint8_t shift, uint8_t mask)
{
    return (uint64_t)((uint64_t)(value & mask) >> shift);
}

int stub_example_message_pack(
    uint8_t* dst_p, const struct stub_example_message_t* src_p, size_t size)
{
    uint16_t temperature;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u8(src_p->enable, 7u, 0x80u);
    dst_p[0] |= pack_left_shift_u8(src_p->average_radius, 1u, 0x7eu);
    temperature = (uint16_t)src_p->temperature;
    dst_p[0] |= pack_right_shift_u16(temperature, 11u, 0x01u);
    dst_p[1] |= pack_right_shift_u16(temperature, 3u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(temperature, 5u, 0xe0u);

    return (8);
}

int stub_example_message_unpack(
    struct stub_example_message_t* dst_p, const uint8_t* src_p, size_t size)
{
    uint16_t temperature;

    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->enable = unpack_right_shift_u8(src_p[0], 7u, 0x80u);
    dst_p->average_radius = unpack_right_shift_u8(src_p[0], 1u, 0x7eu);
    temperature = unpack_left_shift_u16(src_p[0], 11u, 0x01u);
    temperature |= unpack_left_shift_u16(src_p[1], 3u, 0xffu);
    temperature |= unpack_right_shift_u16(src_p[2], 5u, 0xe0u);

    if ((temperature & (1u << 11)) != 0u) {
        temperature |= 0xf000u;
    }

    dst_p->temperature = (int16_t)temperature;

    return (0);
}

int stub_example_message_init(struct stub_example_message_t* msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct stub_example_message_t));

    return 0;
}

uint8_t stub_example_message_enable_encode(double value)
{
    return (uint8_t)(value);
}

double stub_example_message_enable_decode(uint8_t value)
{
    return ((double)value);
}

bool stub_example_message_enable_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t stub_example_message_average_radius_encode(double value)
{
    return (uint8_t)(value / 0.1);
}

double stub_example_message_average_radius_decode(uint8_t value)
{
    return ((double)value * 0.1);
}

bool stub_example_message_average_radius_is_in_range(uint8_t value)
{
    return (value <= 50u);
}

int16_t stub_example_message_temperature_encode(double value)
{
    return (int16_t)((value - 250.0) / 0.01);
}

double stub_example_message_temperature_decode(int16_t value)
{
    return (((double)value * 0.01) + 250.0);
}

bool stub_example_message_temperature_is_in_range(int16_t value)
{
    return ((value >= -2048) && (value <= 2047));
}

int stub_example_message2_pack(
    uint8_t* dst_p, const struct stub_example_message2_t* src_p, size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u8(src_p->radius, 1u, 0x7eu);

    return (8);
}

int stub_example_message2_unpack(
    struct stub_example_message2_t* dst_p, const uint8_t* src_p, size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->radius = unpack_right_shift_u8(src_p[0], 1u, 0x7eu);

    return (0);
}

int stub_example_message2_init(struct stub_example_message2_t* msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct stub_example_message2_t));

    return 0;
}

uint8_t stub_example_message2_radius_encode(double value)
{
    return (uint8_t)(value / 0.1);
}

double stub_example_message2_radius_decode(uint8_t value)
{
    return ((double)value * 0.1);
}

bool stub_example_message2_radius_is_in_range(uint8_t value)
{
    return (value <= 50u);
}

int stub_function_example_pack(
    uint8_t* dst_p, const struct stub_function_example_t* src_p, size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u8(src_p->crc, 0u, 0xffu);
    dst_p[1] |= pack_left_shift_u8(src_p->alive, 0u, 0xffu);
    dst_p[2] |= pack_left_shift_u8(src_p->foo, 0u, 0xffu);
    dst_p[3] |= pack_left_shift_u8(src_p->bar, 0u, 0xffu);

    return (8);
}

int stub_function_example_unpack(
    struct stub_function_example_t* dst_p, const uint8_t* src_p, size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->crc = unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->alive = unpack_right_shift_u8(src_p[1], 0u, 0xffu);
    dst_p->foo = unpack_right_shift_u8(src_p[2], 0u, 0xffu);
    dst_p->bar = unpack_right_shift_u8(src_p[3], 0u, 0xffu);

    return (0);
}

int stub_function_example_init(struct stub_function_example_t* msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct stub_function_example_t));

    return 0;
}

uint8_t stub_function_example_crc_encode(double value)
{
    return (uint8_t)(value);
}

double stub_function_example_crc_decode(uint8_t value)
{
    return ((double)value);
}

bool stub_function_example_crc_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t stub_function_example_alive_encode(double value)
{
    return (uint8_t)(value);
}

double stub_function_example_alive_decode(uint8_t value)
{
    return ((double)value);
}

bool stub_function_example_alive_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t stub_function_example_foo_encode(double value)
{
    return (uint8_t)(value);
}

double stub_function_example_foo_decode(uint8_t value)
{
    return ((double)value);
}

bool stub_function_example_foo_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t stub_function_example_bar_encode(double value)
{
    return (uint8_t)(value);
}

double stub_function_example_bar_decode(uint8_t value)
{
    return ((double)value);
}

bool stub_function_example_bar_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int stub_unsigned_types_pack(
    uint8_t* dst_p, const struct stub_unsigned_types_t* src_p, size_t size)
{
    if (size < 16u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 16);

    dst_p[0] |= pack_right_shift_u8(src_p->u_int8_signal, 7u, 0x01u);
    dst_p[1] |= pack_left_shift_u8(src_p->u_int8_signal, 1u, 0xfeu);
    dst_p[1] |= pack_right_shift_u16(src_p->u_int16_signal, 15u, 0x01u);
    dst_p[2] |= pack_right_shift_u16(src_p->u_int16_signal, 7u, 0xffu);
    dst_p[3] |= pack_left_shift_u16(src_p->u_int16_signal, 1u, 0xfeu);
    dst_p[3] |= pack_right_shift_u32(src_p->u_int32_signal, 31u, 0x01u);
    dst_p[4] |= pack_right_shift_u32(src_p->u_int32_signal, 23u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(src_p->u_int32_signal, 15u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(src_p->u_int32_signal, 7u, 0xffu);
    dst_p[7] |= pack_left_shift_u32(src_p->u_int32_signal, 1u, 0xfeu);
    dst_p[7] |= pack_right_shift_u64(src_p->u_int64_signal, 63u, 0x01u);
    dst_p[8] |= pack_right_shift_u64(src_p->u_int64_signal, 55u, 0xffu);
    dst_p[9] |= pack_right_shift_u64(src_p->u_int64_signal, 47u, 0xffu);
    dst_p[10] |= pack_right_shift_u64(src_p->u_int64_signal, 39u, 0xffu);
    dst_p[11] |= pack_right_shift_u64(src_p->u_int64_signal, 31u, 0xffu);
    dst_p[12] |= pack_right_shift_u64(src_p->u_int64_signal, 23u, 0xffu);
    dst_p[13] |= pack_right_shift_u64(src_p->u_int64_signal, 15u, 0xffu);
    dst_p[14] |= pack_right_shift_u64(src_p->u_int64_signal, 7u, 0xffu);
    dst_p[15] |= pack_left_shift_u64(src_p->u_int64_signal, 1u, 0xfeu);

    return (16);
}

int stub_unsigned_types_unpack(
    struct stub_unsigned_types_t* dst_p, const uint8_t* src_p, size_t size)
{
    if (size < 16u) {
        return (-EINVAL);
    }

    dst_p->u_int8_signal = unpack_left_shift_u8(src_p[0], 7u, 0x01u);
    dst_p->u_int8_signal |= unpack_right_shift_u8(src_p[1], 1u, 0xfeu);
    dst_p->u_int16_signal = unpack_left_shift_u16(src_p[1], 15u, 0x01u);
    dst_p->u_int16_signal |= unpack_left_shift_u16(src_p[2], 7u, 0xffu);
    dst_p->u_int16_signal |= unpack_right_shift_u16(src_p[3], 1u, 0xfeu);
    dst_p->u_int32_signal = unpack_left_shift_u32(src_p[3], 31u, 0x01u);
    dst_p->u_int32_signal |= unpack_left_shift_u32(src_p[4], 23u, 0xffu);
    dst_p->u_int32_signal |= unpack_left_shift_u32(src_p[5], 15u, 0xffu);
    dst_p->u_int32_signal |= unpack_left_shift_u32(src_p[6], 7u, 0xffu);
    dst_p->u_int32_signal |= unpack_right_shift_u32(src_p[7], 1u, 0xfeu);
    dst_p->u_int64_signal = unpack_left_shift_u64(src_p[7], 63u, 0x01u);
    dst_p->u_int64_signal |= unpack_left_shift_u64(src_p[8], 55u, 0xffu);
    dst_p->u_int64_signal |= unpack_left_shift_u64(src_p[9], 47u, 0xffu);
    dst_p->u_int64_signal |= unpack_left_shift_u64(src_p[10], 39u, 0xffu);
    dst_p->u_int64_signal |= unpack_left_shift_u64(src_p[11], 31u, 0xffu);
    dst_p->u_int64_signal |= unpack_left_shift_u64(src_p[12], 23u, 0xffu);
    dst_p->u_int64_signal |= unpack_left_shift_u64(src_p[13], 15u, 0xffu);
    dst_p->u_int64_signal |= unpack_left_shift_u64(src_p[14], 7u, 0xffu);
    dst_p->u_int64_signal |= unpack_right_shift_u64(src_p[15], 1u, 0xfeu);

    return (0);
}

int stub_unsigned_types_init(struct stub_unsigned_types_t* msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct stub_unsigned_types_t));

    return 0;
}

uint8_t stub_unsigned_types_u_int8_signal_encode(double value)
{
    return (uint8_t)(value);
}

double stub_unsigned_types_u_int8_signal_decode(uint8_t value)
{
    return ((double)value);
}

bool stub_unsigned_types_u_int8_signal_is_in_range(uint8_t value)
{
    return (value <= 250u);
}

uint16_t stub_unsigned_types_u_int16_signal_encode(double value)
{
    return (uint16_t)(value);
}

double stub_unsigned_types_u_int16_signal_decode(uint16_t value)
{
    return ((double)value);
}

bool stub_unsigned_types_u_int16_signal_is_in_range(uint16_t value)
{
    return (value <= 1000u);
}

uint32_t stub_unsigned_types_u_int32_signal_encode(double value)
{
    return (uint32_t)(value);
}

double stub_unsigned_types_u_int32_signal_decode(uint32_t value)
{
    return ((double)value);
}

bool stub_unsigned_types_u_int32_signal_is_in_range(uint32_t value)
{
    return (value <= 40000u);
}

uint64_t stub_unsigned_types_u_int64_signal_encode(double value)
{
    return (uint64_t)(value);
}

double stub_unsigned_types_u_int64_signal_decode(uint64_t value)
{
    return ((double)value);
}

bool stub_unsigned_types_u_int64_signal_is_in_range(uint64_t value)
{
    return (value <= 800000ull);
}

int stub_signed_types_pack(
    uint8_t* dst_p, const struct stub_signed_types_t* src_p, size_t size)
{
    uint16_t int16_signal;
    uint32_t int32_signal;
    uint64_t int64_signal;
    uint8_t  int8_signal;

    if (size < 16u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 16);

    int8_signal = (uint8_t)src_p->int8_signal;
    dst_p[0] |= pack_right_shift_u8(int8_signal, 7u, 0x01u);
    dst_p[1] |= pack_left_shift_u8(int8_signal, 1u, 0xfeu);
    int16_signal = (uint16_t)src_p->int16_signal;
    dst_p[1] |= pack_right_shift_u16(int16_signal, 15u, 0x01u);
    dst_p[2] |= pack_right_shift_u16(int16_signal, 7u, 0xffu);
    dst_p[3] |= pack_left_shift_u16(int16_signal, 1u, 0xfeu);
    int32_signal = (uint32_t)src_p->int32_signal;
    dst_p[3] |= pack_right_shift_u32(int32_signal, 31u, 0x01u);
    dst_p[4] |= pack_right_shift_u32(int32_signal, 23u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(int32_signal, 15u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(int32_signal, 7u, 0xffu);
    dst_p[7] |= pack_left_shift_u32(int32_signal, 1u, 0xfeu);
    int64_signal = (uint64_t)src_p->int64_signal;
    dst_p[7] |= pack_right_shift_u64(int64_signal, 63u, 0x01u);
    dst_p[8] |= pack_right_shift_u64(int64_signal, 55u, 0xffu);
    dst_p[9] |= pack_right_shift_u64(int64_signal, 47u, 0xffu);
    dst_p[10] |= pack_right_shift_u64(int64_signal, 39u, 0xffu);
    dst_p[11] |= pack_right_shift_u64(int64_signal, 31u, 0xffu);
    dst_p[12] |= pack_right_shift_u64(int64_signal, 23u, 0xffu);
    dst_p[13] |= pack_right_shift_u64(int64_signal, 15u, 0xffu);
    dst_p[14] |= pack_right_shift_u64(int64_signal, 7u, 0xffu);
    dst_p[15] |= pack_left_shift_u64(int64_signal, 1u, 0xfeu);

    return (16);
}

int stub_signed_types_unpack(
    struct stub_signed_types_t* dst_p, const uint8_t* src_p, size_t size)
{
    uint16_t int16_signal;
    uint32_t int32_signal;
    uint64_t int64_signal;
    uint8_t  int8_signal;

    if (size < 16u) {
        return (-EINVAL);
    }

    int8_signal = unpack_left_shift_u8(src_p[0], 7u, 0x01u);
    int8_signal |= unpack_right_shift_u8(src_p[1], 1u, 0xfeu);
    dst_p->int8_signal = (int8_t)int8_signal;
    int16_signal = unpack_left_shift_u16(src_p[1], 15u, 0x01u);
    int16_signal |= unpack_left_shift_u16(src_p[2], 7u, 0xffu);
    int16_signal |= unpack_right_shift_u16(src_p[3], 1u, 0xfeu);
    dst_p->int16_signal = (int16_t)int16_signal;
    int32_signal = unpack_left_shift_u32(src_p[3], 31u, 0x01u);
    int32_signal |= unpack_left_shift_u32(src_p[4], 23u, 0xffu);
    int32_signal |= unpack_left_shift_u32(src_p[5], 15u, 0xffu);
    int32_signal |= unpack_left_shift_u32(src_p[6], 7u, 0xffu);
    int32_signal |= unpack_right_shift_u32(src_p[7], 1u, 0xfeu);
    dst_p->int32_signal = (int32_t)int32_signal;
    int64_signal = unpack_left_shift_u64(src_p[7], 63u, 0x01u);
    int64_signal |= unpack_left_shift_u64(src_p[8], 55u, 0xffu);
    int64_signal |= unpack_left_shift_u64(src_p[9], 47u, 0xffu);
    int64_signal |= unpack_left_shift_u64(src_p[10], 39u, 0xffu);
    int64_signal |= unpack_left_shift_u64(src_p[11], 31u, 0xffu);
    int64_signal |= unpack_left_shift_u64(src_p[12], 23u, 0xffu);
    int64_signal |= unpack_left_shift_u64(src_p[13], 15u, 0xffu);
    int64_signal |= unpack_left_shift_u64(src_p[14], 7u, 0xffu);
    int64_signal |= unpack_right_shift_u64(src_p[15], 1u, 0xfeu);
    dst_p->int64_signal = (int64_t)int64_signal;

    return (0);
}

int stub_signed_types_init(struct stub_signed_types_t* msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct stub_signed_types_t));

    return 0;
}

int8_t stub_signed_types_int8_signal_encode(double value)
{
    return (int8_t)(value);
}

double stub_signed_types_int8_signal_decode(int8_t value)
{
    return ((double)value);
}

bool stub_signed_types_int8_signal_is_in_range(int8_t value)
{
    (void)value;

    return (true);
}

int16_t stub_signed_types_int16_signal_encode(double value)
{
    return (int16_t)(value);
}

double stub_signed_types_int16_signal_decode(int16_t value)
{
    return ((double)value);
}

bool stub_signed_types_int16_signal_is_in_range(int16_t value)
{
    return ((value >= -2501) && (value <= 2500));
}

int32_t stub_signed_types_int32_signal_encode(double value)
{
    return (int32_t)(value);
}

double stub_signed_types_int32_signal_decode(int32_t value)
{
    return ((double)value);
}

bool stub_signed_types_int32_signal_is_in_range(int32_t value)
{
    return ((value >= -210001) && (value <= 210000));
}

int64_t stub_signed_types_int64_signal_encode(double value)
{
    return (int64_t)(value);
}

double stub_signed_types_int64_signal_decode(int64_t value)
{
    return ((double)value);
}

bool stub_signed_types_int64_signal_is_in_range(int64_t value)
{
    return ((value >= -900001ll) && (value <= 900000ll));
}

int stub_float_types_pack(
    uint8_t* dst_p, const struct stub_float_types_t* src_p, size_t size)
{
    uint32_t float_signal;
    uint64_t double_signal;

    if (size < 16u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 16);

    memcpy(&double_signal, &src_p->double_signal, sizeof(double_signal));
    dst_p[0] |= pack_left_shift_u64(double_signal, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u64(double_signal, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u64(double_signal, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u64(double_signal, 24u, 0xffu);
    dst_p[4] |= pack_right_shift_u64(double_signal, 32u, 0xffu);
    dst_p[5] |= pack_right_shift_u64(double_signal, 40u, 0xffu);
    dst_p[6] |= pack_right_shift_u64(double_signal, 48u, 0xffu);
    dst_p[7] |= pack_right_shift_u64(double_signal, 56u, 0xffu);
    memcpy(&float_signal, &src_p->float_signal, sizeof(float_signal));
    dst_p[8] |= pack_left_shift_u32(float_signal, 0u, 0xffu);
    dst_p[9] |= pack_right_shift_u32(float_signal, 8u, 0xffu);
    dst_p[10] |= pack_right_shift_u32(float_signal, 16u, 0xffu);
    dst_p[11] |= pack_right_shift_u32(float_signal, 24u, 0xffu);

    return (16);
}

int stub_float_types_unpack(
    struct stub_float_types_t* dst_p, const uint8_t* src_p, size_t size)
{
    uint32_t float_signal;
    uint64_t double_signal;

    if (size < 16u) {
        return (-EINVAL);
    }

    double_signal = unpack_right_shift_u64(src_p[0], 0u, 0xffu);
    double_signal |= unpack_left_shift_u64(src_p[1], 8u, 0xffu);
    double_signal |= unpack_left_shift_u64(src_p[2], 16u, 0xffu);
    double_signal |= unpack_left_shift_u64(src_p[3], 24u, 0xffu);
    double_signal |= unpack_left_shift_u64(src_p[4], 32u, 0xffu);
    double_signal |= unpack_left_shift_u64(src_p[5], 40u, 0xffu);
    double_signal |= unpack_left_shift_u64(src_p[6], 48u, 0xffu);
    double_signal |= unpack_left_shift_u64(src_p[7], 56u, 0xffu);
    memcpy(&dst_p->double_signal, &double_signal, sizeof(dst_p->double_signal));
    float_signal = unpack_right_shift_u32(src_p[8], 0u, 0xffu);
    float_signal |= unpack_left_shift_u32(src_p[9], 8u, 0xffu);
    float_signal |= unpack_left_shift_u32(src_p[10], 16u, 0xffu);
    float_signal |= unpack_left_shift_u32(src_p[11], 24u, 0xffu);
    memcpy(&dst_p->float_signal, &float_signal, sizeof(dst_p->float_signal));

    return (0);
}

int stub_float_types_init(struct stub_float_types_t* msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct stub_float_types_t));

    return 0;
}

double stub_float_types_double_signal_encode(double value)
{
    return (double)(value);
}

double stub_float_types_double_signal_decode(double value)
{
    return ((double)value);
}

bool stub_float_types_double_signal_is_in_range(double value)
{
    (void)value;

    return (true);
}

float stub_float_types_float_signal_encode(double value)
{
    return (float)(value);
}

double stub_float_types_float_signal_decode(float value)
{
    return ((double)value);
}

bool stub_float_types_float_signal_is_in_range(float value)
{
    (void)value;

    return (true);
}

int stub_scheduled_message_pack(
    uint8_t* dst_p, const struct stub_scheduled_message_t* src_p, size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u8(src_p->schedule_signal, 0u, 0x01u);

    return (8);
}

int stub_scheduled_message_unpack(
    struct stub_scheduled_message_t* dst_p, const uint8_t* src_p, size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->schedule_signal = unpack_right_shift_u8(src_p[0], 0u, 0x01u);

    return (0);
}

int stub_scheduled_message_init(struct stub_scheduled_message_t* msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct stub_scheduled_message_t));

    return 0;
}

uint8_t stub_scheduled_message_schedule_signal_encode(double value)
{
    return (uint8_t)(value);
}

double stub_scheduled_message_schedule_signal_decode(uint8_t value)
{
    return ((double)value);
}

bool stub_scheduled_message_schedule_signal_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

int stub_mux_message_pack(
    uint8_t* dst_p, const struct stub_mux_message_t* src_p, size_t size)
{
    uint32_t bar_float;
    uint64_t foo_double;

    if (size < 12u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 12);

    dst_p[0] |= pack_left_shift_u32(src_p->header_id, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(src_p->header_id, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(src_p->header_id, 16u, 0xffu);
    dst_p[3] |= pack_left_shift_u8(src_p->header_dlc, 0u, 0xffu);

    switch (src_p->header_id) {
    case 601:
        memcpy(&foo_double, &src_p->foo_double, sizeof(foo_double));
        dst_p[4] |= pack_left_shift_u64(foo_double, 0u, 0xffu);
        dst_p[5] |= pack_right_shift_u64(foo_double, 8u, 0xffu);
        dst_p[6] |= pack_right_shift_u64(foo_double, 16u, 0xffu);
        dst_p[7] |= pack_right_shift_u64(foo_double, 24u, 0xffu);
        dst_p[8] |= pack_right_shift_u64(foo_double, 32u, 0xffu);
        dst_p[9] |= pack_right_shift_u64(foo_double, 40u, 0xffu);
        dst_p[10] |= pack_right_shift_u64(foo_double, 48u, 0xffu);
        dst_p[11] |= pack_right_shift_u64(foo_double, 56u, 0xffu);
        break;

    case 602:
        memcpy(&bar_float, &src_p->bar_float, sizeof(bar_float));
        dst_p[4] |= pack_left_shift_u32(bar_float, 0u, 0xffu);
        dst_p[5] |= pack_right_shift_u32(bar_float, 8u, 0xffu);
        dst_p[6] |= pack_right_shift_u32(bar_float, 16u, 0xffu);
        dst_p[7] |= pack_right_shift_u32(bar_float, 24u, 0xffu);
        break;

    default:
        break;
    }

    return (12);
}

int stub_mux_message_unpack(
    struct stub_mux_message_t* dst_p, const uint8_t* src_p, size_t size)
{
    uint32_t bar_float;
    uint64_t foo_double;

    if (size < 12u) {
        return (-EINVAL);
    }

    dst_p->header_id = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    dst_p->header_id |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    dst_p->header_id |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    dst_p->header_dlc = unpack_right_shift_u8(src_p[3], 0u, 0xffu);

    switch (dst_p->header_id) {
    case 601:
        foo_double = unpack_right_shift_u64(src_p[4], 0u, 0xffu);
        foo_double |= unpack_left_shift_u64(src_p[5], 8u, 0xffu);
        foo_double |= unpack_left_shift_u64(src_p[6], 16u, 0xffu);
        foo_double |= unpack_left_shift_u64(src_p[7], 24u, 0xffu);
        foo_double |= unpack_left_shift_u64(src_p[8], 32u, 0xffu);
        foo_double |= unpack_left_shift_u64(src_p[9], 40u, 0xffu);
        foo_double |= unpack_left_shift_u64(src_p[10], 48u, 0xffu);
        foo_double |= unpack_left_shift_u64(src_p[11], 56u, 0xffu);
        memcpy(&dst_p->foo_double, &foo_double, sizeof(dst_p->foo_double));
        break;

    case 602:
        bar_float = unpack_right_shift_u32(src_p[4], 0u, 0xffu);
        bar_float |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
        bar_float |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
        bar_float |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);
        memcpy(&dst_p->bar_float, &bar_float, sizeof(dst_p->bar_float));
        break;

    default:
        break;
    }

    return (0);
}

int stub_mux_message_init(struct stub_mux_message_t* msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct stub_mux_message_t));

    return 0;
}

uint32_t stub_mux_message_header_id_encode(double value)
{
    return (uint32_t)(value);
}

double stub_mux_message_header_id_decode(uint32_t value)
{
    return ((double)value);
}

bool stub_mux_message_header_id_is_in_range(uint32_t value)
{
    return (value <= 16777215u);
}

uint8_t stub_mux_message_header_dlc_encode(double value)
{
    return (uint8_t)(value);
}

double stub_mux_message_header_dlc_decode(uint8_t value)
{
    return ((double)value);
}

bool stub_mux_message_header_dlc_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

double stub_mux_message_foo_double_encode(double value)
{
    return (double)(value);
}

double stub_mux_message_foo_double_decode(double value)
{
    return ((double)value);
}

bool stub_mux_message_foo_double_is_in_range(double value)
{
    (void)value;

    return (true);
}

float stub_mux_message_bar_float_encode(double value)
{
    return (float)(value);
}

double stub_mux_message_bar_float_decode(float value)
{
    return ((double)value);
}

bool stub_mux_message_bar_float_is_in_range(float value)
{
    (void)value;

    return (true);
}
